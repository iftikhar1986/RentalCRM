import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated, requireAdmin } from "./auth";
import multer from "multer";
import ExcelJS from "exceljs";
import { 
  insertLeadSchema, 
  updateLeadSchema, 
  insertUserSchema, 
  insertBranchSchema, 
  insertBranchUserSchema,
  insertVehicleTypeSchema,
  insertVehicleMakeSchema,
  insertVehicleModelSchema,
  insertVehiclePlateSchema,
  insertFieldConfigurationSchema,
  updateFieldConfigurationSchema,
  bulkVehicleUploadSchema
} from "@shared/schema";
import { fromZodError } from "zod-validation-error";
import { z } from "zod";

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || 
        file.mimetype === 'application/vnd.ms-excel') {
      cb(null, true);
    } else {
      cb(new Error('Only Excel files are allowed'));
    }
  }
});

// Configure multer for image uploads
const imageUpload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit for images
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'));
    }
  }
});

// Dynamic schema creation based on field configurations
async function createDynamicLeadSchema(fieldConfigs: any[]) {
  // Start with base required fields that are essential for the business
  const schemaFields: Record<string, any> = {
    fullName: z.string().min(1, "Full name is required"),
    email: z.string().email("Valid email is required"),
    rentalStartDate: z.string().min(1, "Start date is required").transform((val) => new Date(val)),
    rentalEndDate: z.string().min(1, "End date is required").transform((val) => new Date(val)),
    rentalPeriodDays: z.number().min(1, "Rental period is required"),
    sourceType: z.string().default("website"),
    // Always optional fields
    vehicleModel: z.string().optional(),
    specialRequirements: z.string().optional(),
    customFields: z.record(z.string()).optional(),
  };
  
  // Add conditional fields based on configuration - no duplicates
  fieldConfigs.forEach(config => {
    if (config.isVisible) {
      switch (config.fieldName) {
        case 'phone':
          schemaFields.phone = config.isRequired 
            ? z.string().min(1, "Phone number is required")
            : z.string().optional();
          break;
        case 'location':
          schemaFields.location = config.isRequired 
            ? z.string().min(1, "Location is required")
            : z.string().optional();
          break;
        case 'vehicleType':
          schemaFields.vehicleType = config.isRequired 
            ? z.string().min(1, "Vehicle type is required")
            : z.string().optional();
          break;
        case 'rentalPeriodDays':
          schemaFields.rentalPeriodDays = config.isRequired 
            ? z.number().min(1, "Rental period is required")
            : z.number().optional();
          break;
      }
    }
  });
  
  // Set defaults for fields that are not visible but required in database
  if (!schemaFields.phone) {
    schemaFields.phone = z.string().default("");
  }
  if (!schemaFields.location) {
    schemaFields.location = z.string().default("");
  }
  if (!schemaFields.vehicleType) {
    schemaFields.vehicleType = z.string().default("");
  }
  if (!schemaFields.rentalPeriodDays) {
    schemaFields.rentalPeriodDays = z.number().default(1);
  }
  
  return z.object(schemaFields);
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Note: Auth routes are handled in dummyAuth.ts

  // Profile management endpoints
  app.patch("/api/auth/profile", isAuthenticated, async (req, res) => {
    try {
      const user = req.user as any;
      const { firstName, lastName, email } = req.body;
      const userId = user?.claims?.sub || user?.id;

      // Validate required fields
      if (!firstName || !email) {
        return res.status(400).json({ message: "First name and email are required" });
      }

      // Update user profile
      const updatedUser = await storage.updateUser(userId, {
        firstName: firstName.trim(),
        lastName: lastName?.trim() || null,
        email: email.trim(),
      });

      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Get current user's password for password change form
  app.get("/api/auth/current-password", isAuthenticated, async (req, res) => {
    try {
      const user = req.user as any;
      const userId = user?.claims?.sub || user?.id;

      if (!userId) {
        return res.status(400).json({ message: "User session is invalid" });
      }

      const currentPassword = await storage.getCurrentPassword(userId);
      
      res.json({ currentPassword: currentPassword || '' });
    } catch (error) {
      console.error("Error getting current password:", error);
      res.status(500).json({ message: "Failed to get current password" });
    }
  });

  app.patch("/api/auth/password", isAuthenticated, async (req, res) => {
    try {
      const user = req.user as any;
      const { currentPassword, newPassword } = req.body;

      // Get the actual user ID from claims.sub
      const userId = user?.claims?.sub || user?.id;
      console.log("Password change request for user:", { id: userId, email: user?.email, role: user?.role });

      // Validate required fields
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current password and new password are required" });
      }

      if (!userId) {
        console.error("User ID is missing from session");
        return res.status(400).json({ message: "User session is invalid" });
      }

      // Validate password change
      const success = await storage.changePassword(userId, currentPassword, newPassword);
      
      if (!success) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }

      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  app.post("/api/auth/profile-image", isAuthenticated, imageUpload.single('image'), async (req, res) => {
    try {
      const user = req.user as any;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ message: "No image file provided" });
      }

      // In a real application, you would upload this to a file storage service (S3, etc.)
      // For this demo, we'll just save the filename and simulate upload
      const imageUrl = await storage.updateProfileImage(user.id, file);

      res.json({ imageUrl });
    } catch (error) {
      console.error("Error uploading profile image:", error);
      res.status(500).json({ message: "Failed to upload profile image" });
    }
  });

  // Lead statistics
  app.get("/api/leads/stats", isAuthenticated, async (req, res) => {
    try {
      const user = req.user as any;
      const privacy = req.query.privacy || "enabled";
      let privacyFilters = {};
      
      if (privacy === "enabled") {
        privacyFilters = {
          userId: user.id,
          userRole: user.role,
          userBranchId: user.branchId,
        };
      }

      const stats = await storage.getLeadStats(privacyFilters);
      res.json(stats);
    } catch (error) {
      console.error("Error fetching lead stats:", error);
      res.status(500).json({ message: "Failed to fetch lead statistics" });
    }
  });

  // Get leads with filtering and pagination
  app.get("/api/leads", isAuthenticated, async (req, res) => {
    try {
      const {
        search,
        status,
        dateRange,
        vehicleType,
        location,
        assignedBranch,
        assignedTo,
        startDate,
        endDate,
        archived = "false",
        createdBy,
        page = "1",
        limit = "20"
      } = req.query as Record<string, string>;

      const pageNum = parseInt(page, 10);
      const limitNum = parseInt(limit, 10);
      const offset = (pageNum - 1) * limitNum;

      // Get user info for privacy filtering
      const user = req.user as any;
      const privacy = req.query.privacy || "enabled"; // Privacy toggle parameter
      let privacyFilters = {};
      
      if (privacy === "enabled") {
        privacyFilters = {
          userId: user.id,
          userRole: user.role,
          userBranchId: user.branchId,
        };
      }

      const result = await storage.getLeads({
        search,
        status,
        dateRange,
        vehicleType,
        location,
        assignedBranch,
        assignedTo,
        startDate,
        endDate,
        archived,
        createdBy,
        limit: limitNum,
        offset,
        ...privacyFilters,
      });

      res.json({
        leads: result.leads,
        total: result.total,
        totalCount: result.total,
        page: pageNum,
        totalPages: Math.ceil(result.total / limitNum)
      });
    } catch (error) {
      console.error("Error fetching leads:", error);
      res.status(500).json({ message: "Failed to fetch leads" });
    }
  });

  // Export leads to Excel with privacy controls - MUST come before /:id route
  app.get("/api/leads/export", isAuthenticated, async (req, res) => {
    try {
      const user = req.user as any;
      
      // Check if user has export permissions
      const exportRestrictionSetting = await storage.getPrivacySettingByKey('data_export_restrictions');
      if (exportRestrictionSetting?.isEnabled && user.role !== 'admin') {
        return res.status(403).json({ message: "Export functionality is restricted to administrators only" });
      }

      // Parse filter parameters from query
      const {
        dateFrom,
        dateTo,
        status,
        source,
        branch,
        staff
      } = req.query as Record<string, string | string[]>;

      // Apply privacy filters for export
      const privacyFilters = {
        userId: user.id,
        userRole: user.role,
        userBranchId: user.branchId,
      };

      // Build comprehensive filters
      const exportFilters: any = {
        ...privacyFilters,
      };

      // Add filters only if they exist
      if (dateFrom) exportFilters.startDate = Array.isArray(dateFrom) ? dateFrom[0] : dateFrom;
      if (dateTo) exportFilters.endDate = Array.isArray(dateTo) ? dateTo[0] : dateTo;
      if (status) exportFilters.status = Array.isArray(status) ? status.join(',') : status;
      if (source) exportFilters.sourceType = Array.isArray(source) ? source.join(',') : source;
      if (branch) exportFilters.assignedBranch = Array.isArray(branch) ? branch.join(',') : branch;
      if (staff) exportFilters.createdBy = Array.isArray(staff) ? staff.join(',') : staff;

      const { leads } = await storage.getLeads(exportFilters);
      const fieldConfigs = await storage.getFieldConfigurations();

      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet('Q-Mobility Leads');

      // Base headers
      const baseColumns = [
        { header: 'Full Name', key: 'fullName', width: 20 },
        { header: 'Email', key: 'email', width: 25 },
        { header: 'Phone', key: 'phone', width: 15 },
        { header: 'Location', key: 'location', width: 20 },
        { header: 'Source Type', key: 'sourceType', width: 15 },
        { header: 'Vehicle Type', key: 'vehicleType', width: 15 },
        { header: 'Vehicle Model', key: 'vehicleModel', width: 20 },
        { header: 'Rental Start', key: 'rentalStartDate', width: 15 },
        { header: 'Rental End', key: 'rentalEndDate', width: 15 },
        { header: 'Duration (Days)', key: 'rentalPeriodDays', width: 15 },
        { header: 'Status', key: 'status', width: 12 },
        { header: 'Special Requirements', key: 'specialRequirements', width: 30 },
      ];

      // Add custom field columns
      const customFieldColumns = fieldConfigs
        .filter(config => config.isVisible && 
          !['fullName', 'email', 'phone', 'location', 'vehicleType', 'vehicleModel', 
            'rentalStartDate', 'rentalEndDate', 'rentalPeriodDays', 'status', 'specialRequirements'].includes(config.fieldName))
        .sort((a, b) => (a.fieldOrder || 0) - (b.fieldOrder || 0))
        .map(config => ({
          header: config.label,
          key: config.fieldName,
          width: 20
        }));

      // Combine base and custom columns, add Created At at the end
      worksheet.columns = [
        ...baseColumns,
        ...customFieldColumns,
        { header: 'Created At', key: 'createdAt', width: 20 },
      ];

      // Style header row
      worksheet.getRow(1).font = { bold: true };
      worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF000000' }
      };
      worksheet.getRow(1).font = { color: { argb: 'FFFFFFFF' }, bold: true };

      // Add data
      leads.forEach(lead => {
        const rowData: any = {
          fullName: lead.fullName,
          email: lead.email,
          phone: lead.phone,
          location: lead.location,
          sourceType: lead.sourceType || 'website',
          vehicleType: lead.vehicleType,
          vehicleModel: lead.vehicleModel || '',
          rentalStartDate: lead.rentalStartDate?.toISOString().split('T')[0],
          rentalEndDate: lead.rentalEndDate?.toISOString().split('T')[0],
          rentalPeriodDays: lead.rentalPeriodDays,
          status: lead.status,
          specialRequirements: lead.specialRequirements || '',
          createdAt: lead.createdAt?.toISOString().split('T')[0],
        };

        // Add custom field data
        if (lead.customFields) {
          Object.entries(lead.customFields).forEach(([key, value]) => {
            rowData[key] = value || '';
          });
        }

        worksheet.addRow(rowData);
      });

      // Generate smart filename based on applied filters
      let filename = 'q-mobility-leads';
      const filterParts = [];
      
      if (dateFrom || dateTo) filterParts.push('filtered-dates');
      if (status) filterParts.push('filtered-status');
      if (source) filterParts.push('filtered-source');
      if (branch) filterParts.push('filtered-branch');
      if (staff) filterParts.push('filtered-staff');
      
      if (filterParts.length > 0) {
        filename += '-' + filterParts.join('-');
      }
      
      filename += `-${new Date().toISOString().split('T')[0]}.xlsx`;

      // Set response headers
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename=${filename}`);

      // Write to response
      await workbook.xlsx.write(res);
      res.end();
    } catch (error) {
      console.error("Error exporting leads:", error);
      res.status(500).json({ message: "Failed to export leads" });
    }
  });

  // Get single lead with privacy enforcement
  app.get("/api/leads/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const user = req.user as any;
      const lead = await storage.getLead(id);
      
      if (!lead) {
        return res.status(404).json({ message: "Lead not found" });
      }

      // Apply privacy filtering for single lead access
      const privacyFilters = {
        userId: user.id,
        userRole: user.role,
        userBranchId: user.branchId,
      };

      // Check if user has permission to view this lead
      const hasAccess = await storage.hasLeadAccess(id, privacyFilters);
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied to this lead" });
      }

      // Apply data masking based on privacy settings
      const processedLeads = await storage.applyPrivacyFilteringPublic([lead], privacyFilters);
      
      res.json(processedLeads[0]);
    } catch (error) {
      console.error("Error fetching lead:", error);
      res.status(500).json({ message: "Failed to fetch lead" });
    }
  });

  // Privacy settings routes (admin only)
  app.get("/api/privacy-settings", isAuthenticated, async (req: any, res) => {
    try {
      // Check if user is admin
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Only administrators can access privacy settings" });
      }

      const settings = await storage.getPrivacySettings();
      res.json(settings);
    } catch (error) {
      console.error("Error fetching privacy settings:", error);
      res.status(500).json({ message: "Failed to fetch privacy settings" });
    }
  });

  app.patch("/api/privacy-settings/:id", isAuthenticated, async (req: any, res) => {
    try {
      // Check if user is admin
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Only administrators can modify privacy settings" });
      }

      const { id } = req.params;
      const { isEnabled } = req.body;

      if (typeof isEnabled !== 'boolean') {
        return res.status(400).json({ message: "isEnabled must be a boolean value" });
      }

      const setting = await storage.updatePrivacySetting(id, isEnabled);
      res.json(setting);
    } catch (error) {
      console.error("Error updating privacy setting:", error);
      res.status(500).json({ message: "Failed to update privacy setting" });
    }
  });

  // Create lead with dynamic validation based on field configurations
  app.post("/api/leads", isAuthenticated, async (req, res) => {
    try {
      console.log("Received lead creation request:", JSON.stringify(req.body, null, 2));
      
      // Get field configurations to build dynamic validation
      const fieldConfigs = await storage.getFieldConfigurations();
      const dynamicSchema = await createDynamicLeadSchema(fieldConfigs);
      
      const parsed = dynamicSchema.safeParse(req.body);
      
      if (!parsed.success) {
        console.log("Validation errors:", parsed.error.errors);
        const validationError = fromZodError(parsed.error);
        return res.status(400).json({ message: validationError.message });
      }

      console.log("Parsed lead data:", JSON.stringify(parsed.data, null, 2));

      const user = req.user as any;
      
      // Ensure all required fields are present with defaults
      const leadDataWithDefaults = {
        fullName: parsed.data.fullName,
        email: parsed.data.email,
        phone: parsed.data.phone || "",
        location: parsed.data.location || "",
        vehicleType: parsed.data.vehicleType || "",
        vehicleModel: parsed.data.vehicleModel,
        rentalStartDate: parsed.data.rentalStartDate,
        rentalEndDate: parsed.data.rentalEndDate,
        rentalPeriodDays: parsed.data.rentalPeriodDays || 1,
        sourceType: parsed.data.sourceType || "website",
        specialRequirements: parsed.data.specialRequirements,
        customFields: parsed.data.customFields,
      };
      
      const lead = await storage.createLead(leadDataWithDefaults, user.id, user.branchId);
      res.status(201).json(lead);
    } catch (error) {
      console.error("Error creating lead:", error);
      res.status(500).json({ message: "Failed to create lead" });
    }
  });

  // Update lead with privacy controls
  app.patch("/api/leads/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const user = req.user as any;
      const parsed = updateLeadSchema.safeParse(req.body);
      
      if (!parsed.success) {
        const validationError = fromZodError(parsed.error);
        return res.status(400).json({ message: validationError.message });
      }

      const existingLead = await storage.getLead(id);
      if (!existingLead) {
        return res.status(404).json({ message: "Lead not found" });
      }

      // Check if user has permission to edit this lead
      const privacyFilters = {
        userId: user.id,
        userRole: user.role,
        userBranchId: user.branchId,
      };

      const hasAccess = await storage.hasLeadAccess(id, privacyFilters);
      if (!hasAccess) {
        return res.status(403).json({ message: "Access denied to edit this lead" });
      }

      // Check if staff has edit permissions
      if (user.role === 'staff') {
        const editPermissionsSetting = await storage.getPrivacySettingByKey('staff_edit_permissions');
        if (!editPermissionsSetting?.isEnabled) {
          return res.status(403).json({ message: "Staff editing permissions are currently disabled" });
        }
      }

      const lead = await storage.updateLead(id, parsed.data);
      res.json(lead);
    } catch (error) {
      console.error("Error updating lead:", error);
      res.status(500).json({ message: "Failed to update lead" });
    }
  });

  // Delete lead (admin only)
  app.delete("/api/leads/:id", isAuthenticated, async (req: any, res) => {
    try {
      // Check if user is admin
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Only administrators can delete leads" });
      }

      const { id } = req.params;
      
      const existingLead = await storage.getLead(id);
      if (!existingLead) {
        return res.status(404).json({ message: "Lead not found" });
      }

      await storage.deleteLead(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting lead:", error);
      res.status(500).json({ message: "Failed to delete lead" });
    }
  });

  // Archive lead
  app.patch("/api/leads/:id/archive", isAuthenticated, async (req, res) => {
    try {
      const lead = await storage.archiveLead(req.params.id);
      res.json(lead);
    } catch (error) {
      console.error("Error archiving lead:", error);
      res.status(500).json({ message: "Failed to archive lead" });
    }
  });

  // Bulk actions for leads with privacy controls
  app.post("/api/leads/bulk-action", isAuthenticated, async (req, res) => {
    try {
      const { action, leadIds, status } = req.body;
      const user = req.user as any;

      if (!action || !leadIds || !Array.isArray(leadIds)) {
        return res.status(400).json({ message: "Invalid request body" });
      }

      // Apply privacy restrictions for bulk actions
      if (action === "delete") {
        const deletionRestrictionSetting = await storage.getPrivacySettingByKey('restrict_lead_deletion');
        if (deletionRestrictionSetting?.isEnabled && user.role !== 'admin') {
          return res.status(403).json({ message: "Bulk deletion is restricted to administrators only" });
        }
      }

      switch (action) {
        case "archive":
          await storage.bulkArchiveLeads(leadIds);
          break;
        case "delete":
          await storage.bulkDeleteLeads(leadIds);
          break;
        case "updateStatus":
          if (!status) {
            return res.status(400).json({ message: "Status is required for updateStatus action" });
          }
          await storage.bulkUpdateLeadStatus(leadIds, status);
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }

      res.json({ message: `Bulk ${action} completed successfully` });
    } catch (error) {
      console.error("Error performing bulk action:", error);
      res.status(500).json({ message: "Failed to perform bulk action" });
    }
  });

  // Analytics routes - Export route must come before the period route
  app.get("/api/analytics/export", isAuthenticated, async (req, res) => {
    try {
      const period = req.query.period as string || "6m";
      const analytics = await storage.getAnalytics(period);
      const workbook = new ExcelJS.Workbook();

      // Base headers
      const baseColumns = [
        { header: 'Full Name', key: 'fullName', width: 20 },
        { header: 'Email', key: 'email', width: 25 },
        { header: 'Phone', key: 'phone', width: 15 },
        { header: 'Location', key: 'location', width: 20 },
        { header: 'Source Type', key: 'sourceType', width: 15 },
        { header: 'Vehicle Type', key: 'vehicleType', width: 15 },
        { header: 'Vehicle Model', key: 'vehicleModel', width: 20 },
        { header: 'Rental Start', key: 'rentalStartDate', width: 15 },
        { header: 'Rental End', key: 'rentalEndDate', width: 15 },
        { header: 'Duration (Days)', key: 'rentalPeriodDays', width: 15 },
        { header: 'Status', key: 'status', width: 12 },
        { header: 'Special Requirements', key: 'specialRequirements', width: 30 },
      ];

      // Add custom field columns
      const customFieldColumns = fieldConfigs
        .filter(config => config.isVisible && 
          !['fullName', 'email', 'phone', 'location', 'vehicleType', 'vehicleModel', 
            'rentalStartDate', 'rentalEndDate', 'rentalPeriodDays', 'status', 'specialRequirements'].includes(config.fieldName))
        .sort((a, b) => (a.fieldOrder || 0) - (b.fieldOrder || 0))
        .map(config => ({
          header: config.label,
          key: config.fieldName,
          width: 20
        }));

      // Combine base and custom columns, add Created At at the end
      worksheet.columns = [
        ...baseColumns,
        ...customFieldColumns,
        { header: 'Created At', key: 'createdAt', width: 20 },
      ];

      // Style header row
      worksheet.getRow(1).font = { bold: true };
      worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF000000' }
      };
      worksheet.getRow(1).font = { color: { argb: 'FFFFFFFF' }, bold: true };

      // Add data
      leads.forEach(lead => {
        const rowData: any = {
          fullName: lead.fullName,
          email: lead.email,
          phone: lead.phone,
          location: lead.location,
          sourceType: lead.sourceType || 'website',
          vehicleType: lead.vehicleType,
          vehicleModel: lead.vehicleModel || '',
          rentalStartDate: lead.rentalStartDate?.toISOString().split('T')[0],
          rentalEndDate: lead.rentalEndDate?.toISOString().split('T')[0],
          rentalPeriodDays: lead.rentalPeriodDays,
          status: lead.status,
          specialRequirements: lead.specialRequirements || '',
          createdAt: lead.createdAt?.toISOString().split('T')[0],
        };

        // Add custom field data
        if (lead.customFields) {
          Object.entries(lead.customFields).forEach(([key, value]) => {
            rowData[key] = value || '';
          });
        }

        worksheet.addRow(rowData);
      });

      // Set response headers
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename=q-mobility-leads-${new Date().toISOString().split('T')[0]}.xlsx`);

      // Write to response
      await workbook.xlsx.write(res);
      res.end();
    } catch (error) {
      console.error("Error exporting leads:", error);
      res.status(500).json({ message: "Failed to export leads" });
    }
  });

  // Analytics routes - Export route must come before the period route
  app.get("/api/analytics/export", isAuthenticated, async (req, res) => {
    try {
      const period = req.query.period as string || "6m";
      const analytics = await storage.getAnalytics(period);
      const workbook = new ExcelJS.Workbook();
      
      // Overview Sheet
      const overviewSheet = workbook.addWorksheet('Business Overview');
      overviewSheet.columns = [
        { header: 'Metric', key: 'metric', width: 25 },
        { header: 'Value', key: 'value', width: 15 },
        { header: 'Change', key: 'change', width: 15 }
      ];
      
      overviewSheet.addRows([
        { metric: 'Total Leads', value: analytics.overview.totalLeads, change: `+${analytics.overview.newLeads} this month` },
        { metric: 'Converted Leads', value: analytics.overview.convertedLeads, change: `${analytics.overview.conversionRate}% conversion rate` },
        { metric: 'Conversion Rate', value: `${analytics.overview.conversionRate}%`, change: `${analytics.overview.monthlyGrowth >= 0 ? '+' : ''}${analytics.overview.monthlyGrowth}% growth` },
        { metric: 'Average Response Time', value: `${analytics.overview.averageResponseTime}h`, change: 'Target: <24h' },
        { metric: 'Lead Growth', value: `${analytics.businessInsights.leadGrowth}%`, change: 'Month over month' }
      ]);

      // Branch Performance Sheet
      const branchSheet = workbook.addWorksheet('Branch Performance');
      branchSheet.columns = [
        { header: 'Branch Name', key: 'branchName', width: 20 },
        { header: 'Total Leads', key: 'totalLeads', width: 15 },
        { header: 'Converted Leads', key: 'convertedLeads', width: 15 },
        { header: 'Conversion Rate (%)', key: 'conversionRate', width: 20 },
        { header: 'Recent Leads (30 days)', key: 'recentLeads', width: 20 }
      ];
      branchSheet.addRows(analytics.branchPerformance || []);

      // Vehicle Analysis Sheet
      const vehicleSheet = workbook.addWorksheet('Vehicle Analysis');
      vehicleSheet.columns = [
        { header: 'Vehicle Type', key: 'vehicleType', width: 20 },
        { header: 'Total Leads', key: 'totalLeads', width: 15 },
        { header: 'Converted Leads', key: 'convertedLeads', width: 15 },
        { header: 'Conversion Rate (%)', key: 'conversionRate', width: 20 }
      ];
      vehicleSheet.addRows(analytics.vehicleAnalysis || []);

      // Monthly Trends Sheet
      const trendsSheet = workbook.addWorksheet('Monthly Trends');
      trendsSheet.columns = [
        { header: 'Month', key: 'month', width: 15 },
        { header: 'Total Leads', key: 'leads', width: 15 },
        { header: 'Conversions', key: 'conversions', width: 15 },
        { header: 'Conversion Rate (%)', key: 'conversionRate', width: 20 }
      ];
      trendsSheet.addRows(analytics.monthlyTrends || []);

      // Lead Sources Sheet
      const sourcesSheet = workbook.addWorksheet('Lead Sources');
      sourcesSheet.columns = [
        { header: 'Source', key: 'name', width: 20 },
        { header: 'Total Leads', key: 'value', width: 15 },
        { header: 'Conversion Rate (%)', key: 'conversionRate', width: 20 }
      ];
      sourcesSheet.addRows(analytics.leadSources || []);

      // Staff Performance Sheet
      const staffSheet = workbook.addWorksheet('Staff Performance');
      staffSheet.columns = [
        { header: 'Staff Name', key: 'staffName', width: 20 },
        { header: 'Branch', key: 'branchName', width: 18 },
        { header: 'Staff Type', key: 'type', width: 15 },
        { header: 'Leads Captured', key: 'capturedLeads', width: 15 },
        { header: 'Leads Contacted', key: 'contactedLeads', width: 15 },
        { header: 'Leads Converted', key: 'convertedLeads', width: 15 },
        { header: 'Contact Rate (%)', key: 'contactRate', width: 15 },
        { header: 'Conversion Rate (%)', key: 'conversionRate', width: 18 },
        { header: 'Avg Response Time (hours)', key: 'averageResponseTime', width: 25 },
        { header: 'Performance Rating', key: 'performanceRating', width: 18 }
      ];

      // Add staff performance data with calculated performance ratings
      const staffData = (analytics.staffPerformance || []).map((staff: any, index: number) => ({
        ...staff,
        type: staff.type.replace('_', ' ').toUpperCase(),
        performanceRating: staff.conversionRate >= 25 ? 'EXCELLENT' :
                          staff.conversionRate >= 15 ? 'GOOD' : 
                          'NEEDS IMPROVEMENT',
        rank: index + 1
      }));
      staffSheet.addRows(staffData);

      // Add summary row for staff performance
      if (staffData.length > 0) {
        staffSheet.addRow({});
        staffSheet.addRow({
          staffName: 'TEAM TOTALS',
          branchName: `${staffData.length} Staff Members`,
          type: 'SUMMARY',
          capturedLeads: staffData.reduce((sum: number, s: any) => sum + s.capturedLeads, 0),
          contactedLeads: staffData.reduce((sum: number, s: any) => sum + s.contactedLeads, 0),
          convertedLeads: staffData.reduce((sum: number, s: any) => sum + s.convertedLeads, 0),
          contactRate: Math.round(staffData.reduce((sum: number, s: any) => sum + s.contactRate, 0) / staffData.length),
          conversionRate: Math.round(staffData.reduce((sum: number, s: any) => sum + s.conversionRate, 0) / staffData.length),
          averageResponseTime: Math.round(staffData.filter((s: any) => s.averageResponseTime > 0)
            .reduce((sum: number, s: any) => sum + s.averageResponseTime, 0) / 
            staffData.filter((s: any) => s.averageResponseTime > 0).length * 10) / 10 || 0,
          performanceRating: 'TEAM AVERAGE'
        });

        // Style the summary row
        const summaryRowIndex = staffSheet.rowCount;
        const summaryRow = staffSheet.getRow(summaryRowIndex);
        summaryRow.font = { bold: true };
        summaryRow.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFD4E6F1' }
        };
      }

      // Style headers
      [overviewSheet, branchSheet, vehicleSheet, trendsSheet, sourcesSheet, staffSheet].forEach(sheet => {
        sheet.getRow(1).font = { bold: true };
        sheet.getRow(1).fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFE6E6E6' }
        };
      });

      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename=Q-Mobility-Analytics-${new Date().toISOString().slice(0, 10)}.xlsx`);
      
      await workbook.xlsx.write(res);
      res.end();
    } catch (error) {
      console.error("Error exporting analytics:", error);
      res.status(500).json({ message: "Failed to export analytics" });
    }
  });

  // Analytics data routes (must come after export route)
  app.get("/api/analytics", isAuthenticated, async (req, res) => {
    try {
      const period = req.query.period as string || "6m";
      const analytics = await storage.getAnalytics(period);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  app.get("/api/analytics/:period", isAuthenticated, async (req, res) => {
    try {
      const period = req.params.period;
      const analytics = await storage.getAnalytics(period);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  // User management routes (admin only)
  app.get("/api/users", requireAdmin, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  app.post("/api/users", requireAdmin, async (req, res) => {
    try {
      const { email, firstName, lastName, role = "staff", password } = req.body;
      
      if (!email || !firstName || !lastName || !password) {
        return res.status(400).json({ message: "Email, first name, last name, and password are required" });
      }

      if (password.length < 8) {
        return res.status(400).json({ message: "Password must be at least 8 characters long" });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "User with this email already exists" });
      }

      const userData = {
        email,
        firstName,
        lastName,
        role,
        password,
        isActive: "true"
      };

      const user = await storage.createStaffUser(userData);
      res.status(201).json(user);
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ message: "Failed to create user" });
    }
  });

  app.patch("/api/users/:id/status", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      
      if (isActive !== "true" && isActive !== "false") {
        return res.status(400).json({ message: "isActive must be 'true' or 'false'" });
      }

      // Protect the first admin user from being deactivated
      if (isActive === "false") {
        const isFirstAdmin = await storage.isFirstAdminUser(id);
        if (isFirstAdmin) {
          return res.status(403).json({ 
            message: "The primary administrator account cannot be deactivated for security reasons. This account must remain active to ensure system access." 
          });
        }
      }

      const user = await storage.updateUserStatus(id, isActive);
      res.json(user);
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ message: "Failed to update user status" });
    }
  });

  app.delete("/api/users/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Prevent admin from deleting their own account
      const currentUser = req.user as any;
      if (currentUser.id === id) {
        return res.status(400).json({ message: "You cannot delete your own account" });
      }

      // Check if this is the first admin user (prevent deletion)
      const userToDelete = await storage.getUser(id);
      if (!userToDelete) {
        return res.status(404).json({ message: "User not found" });
      }

      // Protect the first admin user from deletion
      const isFirstAdmin = await storage.isFirstAdminUser(id);
      if (isFirstAdmin) {
        return res.status(403).json({ 
          message: "The primary administrator account cannot be deleted for security reasons. This account is protected to ensure system access is maintained." 
        });
      }
      
      await storage.deleteUser(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Failed to delete user" });
    }
  });

  // Branch management routes (admin only)
  app.get("/api/branches", requireAdmin, async (req, res) => {
    try {
      const branches = await storage.getBranches();
      res.json(branches);
    } catch (error) {
      console.error("Error fetching branches:", error);
      res.status(500).json({ message: "Failed to fetch branches" });
    }
  });

  app.post("/api/branches", requireAdmin, async (req, res) => {
    try {
      const parsed = insertBranchSchema.safeParse(req.body);
      
      if (!parsed.success) {
        const validationError = fromZodError(parsed.error);
        return res.status(400).json({ message: validationError.message });
      }

      const branch = await storage.createBranch(parsed.data);
      res.status(201).json(branch);
    } catch (error) {
      console.error("Error creating branch:", error);
      res.status(500).json({ message: "Failed to create branch" });
    }
  });

  app.patch("/api/branches/:id/status", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      
      if (typeof isActive !== "string") {
        return res.status(400).json({ message: "isActive must be a string" });
      }

      const branch = await storage.updateBranchStatus(id, isActive);
      res.json(branch);
    } catch (error) {
      console.error("Error updating branch status:", error);
      res.status(500).json({ message: "Failed to update branch status" });
    }
  });

  app.delete("/api/branches/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteBranch(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting branch:", error);
      res.status(500).json({ message: "Failed to delete branch" });
    }
  });

  // Branch User management routes (admin only)
  app.get("/api/branches/:branchId/users", requireAdmin, async (req, res) => {
    try {
      const { branchId } = req.params;
      const branchUsers = await storage.getBranchUsers(branchId);
      res.json(branchUsers);
    } catch (error) {
      console.error("Error fetching branch users:", error);
      res.status(500).json({ message: "Failed to fetch branch users" });
    }
  });

  app.post("/api/branches/:branchId/users", requireAdmin, async (req, res) => {
    try {
      const { branchId } = req.params;
      const parsed = insertBranchUserSchema.safeParse({ ...req.body, branchId });
      
      if (!parsed.success) {
        const validationError = fromZodError(parsed.error);
        return res.status(400).json({ message: validationError.message });
      }

      const branchUser = await storage.createBranchUser(parsed.data);
      res.status(201).json(branchUser);
    } catch (error) {
      console.error("Error creating branch user:", error);
      res.status(500).json({ message: "Failed to create branch user" });
    }
  });

  app.patch("/api/branch-users/:id/status", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      
      if (typeof isActive !== "string") {
        return res.status(400).json({ message: "isActive must be a string" });
      }

      const branchUser = await storage.updateBranchUserStatus(id, isActive);
      res.json(branchUser);
    } catch (error) {
      console.error("Error updating branch user status:", error);
      res.status(500).json({ message: "Failed to update branch user status" });
    }
  });

  app.delete("/api/branch-users/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteBranchUser(id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting branch user:", error);
      res.status(500).json({ message: "Failed to delete branch user" });
    }
  });

  // Get all branch users for filtering (admin and manager)
  app.get("/api/branch-users", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user;
      console.log("Branch users API - User:", user);
      
      // Check if user has permission (admin or manager)
      if (user.role !== 'admin' && user.role !== 'manager') {
        return res.status(403).json({ message: "Access denied" });
      }

      let branchUsers: any[] = [];
      if (user.role === 'admin') {
        // Admin can see all branch users
        console.log("Fetching all branch users for admin");
        branchUsers = await storage.getAllBranchUsers();
      } else if (user.role === 'manager' && user.branchId) {
        // Manager can only see users from their branch
        console.log("Fetching branch users for manager, branchId:", user.branchId);
        branchUsers = await storage.getBranchUsers(user.branchId);
        console.log("Found branch users:", branchUsers);
      } else {
        console.log("No valid condition met, returning empty array");
        branchUsers = [];
      }

      res.json(branchUsers);
    } catch (error) {
      console.error("Error fetching all branch users:", error);
      res.status(500).json({ message: "Failed to fetch branch users" });
    }
  });

  // Vehicle management routes
  
  // Vehicle Types - GET available to all authenticated users for lead form
  app.get("/api/vehicles/types", isAuthenticated, async (req, res) => {
    try {
      const vehicleTypes = await storage.getVehicleTypes();
      res.json(vehicleTypes);
    } catch (error) {
      console.error("Error fetching vehicle types:", error);
      res.status(500).json({ message: "Failed to fetch vehicle types" });
    }
  });

  app.post("/api/vehicles/types", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      console.log("Vehicle type creation request body:", req.body);
      const result = insertVehicleTypeSchema.safeParse(req.body);
      if (!result.success) {
        console.error("Vehicle type validation failed:", result.error);
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      console.log("Vehicle type validated data:", result.data);
      const vehicleType = await storage.createVehicleType(result.data);
      console.log("Vehicle type created successfully:", vehicleType);
      res.status(201).json(vehicleType);
    } catch (error) {
      console.error("Error creating vehicle type:", error);
      res.status(500).json({ message: "Failed to create vehicle type" });
    }
  });

  app.put("/api/vehicles/types/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehicleTypeSchema.partial().safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehicleType = await storage.updateVehicleType(req.params.id, result.data);
      res.json(vehicleType);
    } catch (error) {
      console.error("Error updating vehicle type:", error);
      res.status(500).json({ message: "Failed to update vehicle type" });
    }
  });

  app.delete("/api/vehicles/types/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      await storage.deleteVehicleType(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting vehicle type:", error);
      res.status(500).json({ message: "Failed to delete vehicle type" });
    }
  });

  // Vehicle Makes - GET available to all authenticated users for lead form
  app.get("/api/vehicles/makes", isAuthenticated, async (req, res) => {
    try {
      const vehicleMakes = await storage.getVehicleMakes();
      res.json(vehicleMakes);
    } catch (error) {
      console.error("Error fetching vehicle makes:", error);
      res.status(500).json({ message: "Failed to fetch vehicle makes" });
    }
  });

  app.post("/api/vehicles/makes", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehicleMakeSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehicleMake = await storage.createVehicleMake(result.data);
      res.status(201).json(vehicleMake);
    } catch (error) {
      console.error("Error creating vehicle make:", error);
      res.status(500).json({ message: "Failed to create vehicle make" });
    }
  });

  app.put("/api/vehicles/makes/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehicleMakeSchema.partial().safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehicleMake = await storage.updateVehicleMake(req.params.id, result.data);
      res.json(vehicleMake);
    } catch (error) {
      console.error("Error updating vehicle make:", error);
      res.status(500).json({ message: "Failed to update vehicle make" });
    }
  });

  app.delete("/api/vehicles/makes/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      await storage.deleteVehicleMake(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting vehicle make:", error);
      res.status(500).json({ message: "Failed to delete vehicle make" });
    }
  });

  // Vehicle Models - GET available to all authenticated users for lead form
  app.get("/api/vehicles/models", isAuthenticated, async (req, res) => {
    try {
      const vehicleModels = await storage.getVehicleModels();
      res.json(vehicleModels);
    } catch (error) {
      console.error("Error fetching vehicle models:", error);
      res.status(500).json({ message: "Failed to fetch vehicle models" });
    }
  });

  app.post("/api/vehicles/models", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehicleModelSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehicleModel = await storage.createVehicleModel(result.data);
      res.status(201).json(vehicleModel);
    } catch (error) {
      console.error("Error creating vehicle model:", error);
      res.status(500).json({ message: "Failed to create vehicle model" });
    }
  });

  app.put("/api/vehicles/models/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehicleModelSchema.partial().safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehicleModel = await storage.updateVehicleModel(req.params.id, result.data);
      res.json(vehicleModel);
    } catch (error) {
      console.error("Error updating vehicle model:", error);
      res.status(500).json({ message: "Failed to update vehicle model" });
    }
  });

  app.delete("/api/vehicles/models/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      await storage.deleteVehicleModel(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting vehicle model:", error);
      res.status(500).json({ message: "Failed to delete vehicle model" });
    }
  });

  // Vehicle Plates
  app.get("/api/vehicles/plates", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const vehiclePlates = await storage.getVehiclePlates();
      res.json(vehiclePlates);
    } catch (error) {
      console.error("Error fetching vehicle plates:", error);
      res.status(500).json({ message: "Failed to fetch vehicle plates" });
    }
  });

  app.post("/api/vehicles/plates", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehiclePlateSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehiclePlate = await storage.createVehiclePlate(result.data);
      res.status(201).json(vehiclePlate);
    } catch (error) {
      console.error("Error creating vehicle plate:", error);
      res.status(500).json({ message: "Failed to create vehicle plate" });
    }
  });

  app.put("/api/vehicles/plates/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertVehiclePlateSchema.partial().safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }
      const vehiclePlate = await storage.updateVehiclePlate(req.params.id, result.data);
      res.json(vehiclePlate);
    } catch (error) {
      console.error("Error updating vehicle plate:", error);
      res.status(500).json({ message: "Failed to update vehicle plate" });
    }
  });

  app.delete("/api/vehicles/plates/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      await storage.deleteVehiclePlate(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting vehicle plate:", error);
      res.status(500).json({ message: "Failed to delete vehicle plate" });
    }
  });

  // Bulk vehicle upload endpoint (Admin only)
  app.post("/api/vehicles/bulk-upload", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = bulkVehicleUploadSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }

      const uploadResult = await storage.bulkUploadVehicles(result.data);
      res.status(201).json(uploadResult);
    } catch (error) {
      console.error("Error in bulk vehicle upload:", error);
      res.status(500).json({ message: "Failed to upload vehicles" });
    }
  });

  // Excel bulk upload endpoint (Admin only)
  app.post("/api/vehicles/bulk-upload-excel", isAuthenticated, requireAdmin, upload.single('file'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const workbook = new ExcelJS.Workbook();
      await workbook.xlsx.load(req.file.buffer);

      const vehicleData: any = {
        vehicleTypes: [],
        vehicleMakes: [],
        vehicleModels: [],
        vehiclePlates: []
      };

      // Process Types sheet
      const typesSheet = workbook.getWorksheet('Types');
      if (typesSheet) {
        typesSheet.eachRow((row, rowNumber) => {
          if (rowNumber === 1) return; // Skip header
          const values = row.values as any[];
          const name = values[1];
          const description = values[2];
          if (name && String(name).trim()) {
            vehicleData.vehicleTypes.push({ 
              name: String(name).trim(), 
              description: description ? String(description).trim() : '' 
            });
          }
        });
      }

      // Process Makes sheet
      const makesSheet = workbook.getWorksheet('Makes');
      if (makesSheet) {
        makesSheet.eachRow((row, rowNumber) => {
          if (rowNumber === 1) return; // Skip header
          const values = row.values as any[];
          const name = values[1];
          const logoUrl = values[2];
          if (name && String(name).trim()) {
            vehicleData.vehicleMakes.push({ 
              name: String(name).trim(), 
              logoUrl: logoUrl ? String(logoUrl).trim() : '' 
            });
          }
        });
      }

      // Get existing data for lookup
      const existingMakes = await storage.getVehicleMakes();
      const existingTypes = await storage.getVehicleTypes();
      const existingModels = await storage.getVehicleModels();

      // Process Models sheet
      const modelsSheet = workbook.getWorksheet('Models');
      if (modelsSheet) {
        modelsSheet.eachRow((row, rowNumber) => {
          if (rowNumber === 1) return; // Skip header
          const values = row.values as any[];
          const name = values[1];
          const makeName = values[2];
          const typeName = values[3];
          const year = values[4];
          
          if (name && String(name).trim() && makeName && typeName) {
            // Find makeId and typeId based on names
            const make = existingMakes.find(m => m.name.toLowerCase() === String(makeName).trim().toLowerCase());
            const type = existingTypes.find(t => t.name.toLowerCase() === String(typeName).trim().toLowerCase());
            
            if (make && type) {
              vehicleData.vehicleModels.push({
                name: String(name).trim(),
                makeId: make.id,
                typeId: type.id,
                year: year ? parseInt(String(year)) : new Date().getFullYear()
              });
            }
          }
        });
      }

      // Process Plates sheet
      const platesSheet = workbook.getWorksheet('Plates');
      if (platesSheet) {
        platesSheet.eachRow((row, rowNumber) => {
          if (rowNumber === 1) return; // Skip header
          const values = row.values as any[];
          const plateNumber = values[1];
          const modelName = values[2];
          const color = values[3];
          const status = values[4];
          
          if (plateNumber && String(plateNumber).trim() && modelName) {
            // Find modelId based on name
            const model = existingModels.find(m => m.name.toLowerCase() === String(modelName).trim().toLowerCase());
            
            if (model) {
              vehicleData.vehiclePlates.push({
                plateNumber: String(plateNumber).trim(),
                modelId: model.id,
                color: color ? String(color).trim() : '',
                status: status ? String(status).trim() : 'available'
              });
            }
          }
        });
      }

      const uploadResult = await storage.bulkUploadVehicles(vehicleData);
      res.status(201).json(uploadResult);
    } catch (error) {
      console.error("Error in Excel bulk upload:", error);
      res.status(500).json({ message: "Failed to upload Excel file" });
    }
  });

  // Download Excel template endpoint (Admin only)
  app.get("/api/vehicles/bulk-upload-template", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const workbook = new ExcelJS.Workbook();

      // Create Types sheet
      const typesSheet = workbook.addWorksheet('Types');
      typesSheet.addRow(['Name', 'Description']);
      typesSheet.addRow(['SUV', 'Sport Utility Vehicle']);
      typesSheet.addRow(['Sedan', 'Four-door passenger car']);
      typesSheet.addRow(['Hatchback', 'Compact car with rear door']);

      // Create Makes sheet
      const makesSheet = workbook.addWorksheet('Makes');
      makesSheet.addRow(['Name', 'Logo URL']);
      makesSheet.addRow(['Toyota', 'https://example.com/toyota-logo.png']);
      makesSheet.addRow(['Honda', 'https://example.com/honda-logo.png']);
      makesSheet.addRow(['Nissan', 'https://example.com/nissan-logo.png']);

      // Create Models sheet
      const modelsSheet = workbook.addWorksheet('Models');
      modelsSheet.addRow(['Name', 'Make Name', 'Type Name', 'Year']);
      modelsSheet.addRow(['Camry', 'Toyota', 'Sedan', 2024]);
      modelsSheet.addRow(['Prado', 'Toyota', 'SUV', 2024]);
      modelsSheet.addRow(['Civic', 'Honda', 'Sedan', 2024]);

      // Create Plates sheet
      const platesSheet = workbook.addWorksheet('Plates');
      platesSheet.addRow(['Plate Number', 'Model Name', 'Color', 'Status']);
      platesSheet.addRow(['ABC-123', 'Camry', 'White', 'available']);
      platesSheet.addRow(['XYZ-789', 'Prado', 'Black', 'available']);
      platesSheet.addRow(['DEF-456', 'Civic', 'Silver', 'available']);

      // Set column widths
      [typesSheet, makesSheet, modelsSheet, platesSheet].forEach(sheet => {
        sheet.columns.forEach(column => {
          column.width = 20;
        });
        // Make header row bold
        sheet.getRow(1).font = { bold: true };
      });

      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', 'attachment; filename=vehicle_bulk_upload_template.xlsx');

      await workbook.xlsx.write(res);
      res.end();
    } catch (error) {
      console.error("Error generating template:", error);
      res.status(500).json({ message: "Failed to generate template" });
    }
  });

  // Field Configuration routes
  // GET endpoint is available to all authenticated users for lead form creation
  app.get("/api/field-configurations", isAuthenticated, async (req, res) => {
    try {
      const configs = await storage.getFieldConfigurations();
      res.json(configs);
    } catch (error) {
      console.error("Error fetching field configurations:", error);
      res.status(500).json({ message: "Failed to fetch field configurations" });
    }
  });

  app.post("/api/field-configurations", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = insertFieldConfigurationSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }

      const config = await storage.createFieldConfiguration(result.data);
      res.status(201).json(config);
    } catch (error) {
      console.error("Error creating field configuration:", error);
      res.status(500).json({ message: "Failed to create field configuration" });
    }
  });

  app.patch("/api/field-configurations/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const result = updateFieldConfigurationSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: fromZodError(result.error).toString() });
      }

      const config = await storage.updateFieldConfiguration(req.params.id, result.data);
      res.json(config);
    } catch (error) {
      console.error("Error updating field configuration:", error);
      res.status(500).json({ message: "Failed to update field configuration" });
    }
  });

  app.delete("/api/field-configurations/:id", isAuthenticated, requireAdmin, async (req, res) => {
    try {
      await storage.deleteFieldConfiguration(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting field configuration:", error);
      res.status(500).json({ message: "Failed to delete field configuration" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
